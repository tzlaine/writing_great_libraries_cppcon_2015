<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Writing Great Libraries CppCon 2015</title>

    <meta name="author", content="T. Zachary Laine">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="presentation/css/reveal.css">
    <link rel="stylesheet" href="presentation/css/theme/default.css" id="theme">

    <link rel="stylesheet" href="presentation/lib/css/zenburn.css">

    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'presentation/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <script src="presentation/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown=""
               data-separator="^====+$"
               data-vertical="^----+$"
               data-notes="^Note:">
        <script type="text/template">

# Writing Great Libraries
## 89 Easy Steps
### Zach Laine, CppCon 2015

====================

## Outline
- Motivation
- Efficiency
- Usability
- Implementation Tips

====================

# Part 1
## Motivation

### Let's start from first principles.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

## Why do we write libraries?

### Code reuse of course!
<!-- .element: class="fragment" data-fragment-index="1" -->

### This is the guiding principle that should drive all our work as library writers.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### What makes library code different from application code?

We don't know all the requirements for use at the time we write the code.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

Q: How much time can I spend in `handle_click()` and still be efficient enough?

```cpp
void handle_click()
{
    // ...
}
button_t button;
button.connect(&handle_click);
```

A: A lot!  I have about 100 milliseconds to do whatever I want, because the
user will never notice any latency less than that after a click.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

Q: What about here?

```cpp
namespace my_lib {
    void foo ()
    {
        // ...
    }
}
```

A: I have no idea
<!-- .element: class="fragment" data-fragment-index="1" -->

... and neither do you.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

We must make a library as usable as possible to anyone that might want to use
it (and no more).

That implies efficiency is our goal, since we're working in C++, and maximum efficiency, since we don't know the usage context.
<!-- .element: class="fragment" data-fragment-index="1" -->

It also implies maximal reusability, for the same reason.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

There are two audiences you are writing for when you write code: human readers
and the compiler.  You have to make your code easy to reason about for *both*
audiences as a library writer.

Messy implementation details need to be isolated from the public interface.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### To Summarize

### Principle 0: We write libraries for code reuse.
<!-- .element: class="fragment" data-fragment-index="1" -->

### Principle 1: Libraries must be maxmially efficient (see Principle 0).
<!-- .element: class="fragment" data-fragment-index="2" -->

### Principle 2: Libraries must be maxmially usable (see Principle 0).
<!-- .element: class="fragment" data-fragment-index="3" -->

====================

# Part 2
## Efficiency

----

We all know lots of guidelines for making C++ efficient:

Make your moves noexcept.
<!-- .element: class="fragment" data-fragment-index="1" -->

Minimize copies.
<!-- .element: class="fragment" data-fragment-index="2" -->

Minimize resource allocation.
<!-- .element: class="fragment" data-fragment-index="3" -->

Etc....
<!-- .element: class="fragment" data-fragment-index="4" -->

----

Those are all implementation guidelines.

We must derive interface guidelines from such implementation guidelines.
<!-- .element: class="fragment" data-fragment-index="1" -->

How do we do this, when we don't know the usage context?
<!-- .element: class="fragment" data-fragment-index="2" -->

----

### An Example: Getting a sequence of things

The C way:

```cpp
struct X { /*...*/ };

int num_xs ();

const X* get_x (int i);
```

```cpp
const int num = num_xs();
for (int i = 0; i < num; ++i) {
    const X* x = get_x(i);
    use(x);
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

----

This interface requires:

- Checking of the parameter to `get_x()` in library code (N*2 branches).
- Checking the result of `get_x()` in user code (N branches).
- N+1 function calls.

----

We would like:

- Minimal branches
- Minimal function calls

----

Maybe this is better?

```cpp
std::vector<X> get_xs ();
```

A bit, yes.  We only need to call one function, and there are no more
per-element branches.
<!-- .element: class="fragment" data-fragment-index="1" -->

However, do we really need to allocate memory?  Maybe the user just needs to
see each element, not copy it.
<!-- .element: class="fragment" data-fragment-index="2" -->

Also, what happens if the range has no bound?
<!-- .element: class="fragment" data-fragment-index="3" -->

----

Better still is a lazy range:

```cpp
struct x_range {
    // iterator into our internal storage
    using iterator = std::vector<X>::const_iterator;
    iterator first, last;
};

x_range::iterator begin (x_range r)
{ return r.first; }

x_range::iterator end (x_range r)
{ return r.last; }

std::size_t size (x_range r)
{ return end(r) - begin(r); }

x_range get_xs ();
```

----

```cpp
x_range range = get_xs();
for (auto const & x : range) {
    use(x);
}

// This will use memcpy for PODs, etc.
std::vector<X> copy_of_xs(size(range));
std::copy(begin(range), end(range), copy_of_xs.begin());
```

----

This still doesn't handle unbounded ranges, but it could if you changed the
iterators to input iterators.

This gives up the copyability properties, though.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### Efficiency Guidelines

Your code needs to be efficient, under all reasonably forseeable usage scenarios.
<!-- .element: class="fragment" data-fragment-index="1" -->

To get there, constantly ask "what if ...".
<!-- .element: class="fragment" data-fragment-index="2" -->

Don't be stupid.
<!-- .element: class="fragment" data-fragment-index="3" -->

====================

# Part 3
## Usability

----

## Names Are Important

Don't give your interfaces unintuitive names!
<!-- .element: class="fragment" data-fragment-index="1" -->

----

### An Example: Selecting from a Sequence

```cpp
struct X
{
    int value;
    /*...*/
};
std::vector<X> xs = {/*...*/};
std::vector<X> selected_xs;

filter(
    xs.begin(),
    xs.end(),
    std::back_inserter(selected_xs),
    [](X const & x) { return x.value == 42; }
);
```

What does this do?

Does it filter in or filter out?
<!-- .element: class="fragment" data-fragment-index="1" -->

Go find out!  I'll wait....
<!-- .element: class="fragment" data-fragment-index="2" -->

----

```cpp
std::copy_if(
    xs.begin(),
    xs.end(),
    std::back_inserter(selected_xs),
    [](X const & x) { return x.value == 42; }
);
```

What does this do?

Everyone here knows what this does.
<!-- .element: class="fragment" data-fragment-index="1" -->

Unclear (nonobvious) names make code hard to reason about, and thus decrease
productivity.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

##The Principle of Least Surprise

Don't make your interfaces do unexpectable things.

----

###An Example:

```cpp
struct X
{/*...*/};

void RegisterX(X const * x);
X * x = new X{/*...*/};
RegisterX(x);
```

This looks pretty clear, right?

----

```cpp
void RegisterX(X const * x)
{
    if (x) {
        // Some stuff that "registers" x here...
    }
    delete x; // WTF
}
```

How was I supposed to know this would happen?
<!-- .element: class="fragment" data-fragment-index="1" -->

That name is so misleading!
<!-- .element: class="fragment" data-fragment-index="2" -->

Names are important.
<!-- .element: class="fragment" data-fragment-index="3" -->

----

##Make interfaces impossible to use incorrectly

If that proves impossible, make interfaces difficult to use incorrectly.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

###An example:

What happens when we try to restrict the number of X's we want?

```cpp
int num = num_xs();
// some code to here change num,
// in order to take a subset of num_xs() ...
for (int i = 0; i < num; ++i) {
    const X* x = get_x(i);
    use(x);
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

We might introduce an indexing error!
<!-- .element: class="fragment" data-fragment-index="1" -->

If num_xs() < num and we do not check that x != nullptr, we get UB (and a crash if we're lucky).
<!-- .element: class="fragment" data-fragment-index="2" -->

----

We are less likely to get errors of this kind using the range-based approach,
because we are not allowed to directly index into the range.

If we change the iterator category of the range to InputIterator, the indexing
errors become impossible.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

##Avoid Aliasing

Aliasing confuses you, your users, and the compiler.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

###An example:

```cpp
void xor_swap (int & a, int & b)
{
    a ^= b;
    b ^= a;
    a ^= b;
}
```

Why is this wrong?

----

```cpp
void xor_swap (int & a, int & b)
{
    if (&a != &b) {
        a ^= b;
        b ^= a;
        a ^= b;
    }
}
```

Why is this bad?

The extra branch is certainly bad.
<!-- .element: class="fragment" data-fragment-index="1" -->

Having to consider such things as identity is pretty bad too.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

```cpp
void xor_swap (int & a_, int & b_)
{
    int a = a_, b = b_;

    a ^= b;
    b ^= a;
    a ^= b;

    a_ = a; b_ = b;
}
```

This is better.

```cpp
std::pair<int, int> xor_swap (int a, int b)
{
    a ^= b;
    b ^= a;
    a ^= b;
    return std::make_pair(a, b);
}
```
<!-- .element: class="fragment" data-fragment-index="1" -->

So is this.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

As a guideline, avoid pointers and references wherever possible, to avoid your
own difficulty in understanding your implementation.

Sometimes references are unavoidable.
<!-- .element: class="fragment" data-fragment-index="1" -->

Look at the code your compiler generates to determine if this is really the case.
<!-- .element: class="fragment" data-fragment-index="2" -->

----

###Another example:

```cpp
struct Base { /*...*/ };

struct S : Base { /*...*/ };

unsigned int * get_index (Base & b);

std::pair<S *, unsigned int *> make_s_with_index ();
```

As a user of make_s_with_index() who does not have access to the
implementation, what are your questions about how it behaves?
<!-- .element: class="fragment" data-fragment-index="1" -->

----

Possible implementation:

```cpp
std::pair<S *, unsigned int *> make_s_with_index ()
{
    std::pair<S *, unsigned int *> retval{new S, nullptr};
    retval.second = get_index(*retval.first);
}
```

1) Does get_index() throw?
<!-- .element: class="fragment" data-fragment-index="1" -->

2) If the answer to 1 is true, does that mean that make_s_with_index() throws too?
<!-- .element: class="fragment" data-fragment-index="2" -->

3) If the answer to 2 is false, does that mean that make_s_with_index()
swallows all exceptions produced by get_index()?
<!-- .element: class="fragment" data-fragment-index="3" -->

----

How about this instead?

```cpp
struct Base { /*...*/ };

struct S : Base { /*...*/ };

unsigned int * get_index (Base & b);

// We could also use std::unique_ptr<S> here.
std::pair<S, unsigned int *> make_s_with_index ();
```

I no longer have any of those questions from before.  From the interface alone, I know the answers:
<!-- .element: class="fragment" data-fragment-index="1" -->

1) Whether get_index() throws is largely moot -- see below.
<!-- .element: class="fragment" data-fragment-index="2" -->

2) If get_index() throws, so does make_s_with_index().
<!-- .element: class="fragment" data-fragment-index="3" -->

3) Whatever get_index() throws, make_s_with_index() throws the same thing.
<!-- .element: class="fragment" data-fragment-index="4" -->

----

As another guideline, keep (raw and shared-) pointers and references out of
your APIs.  They make your code harder to reason about.

Raw and shared pointers are shared state.  They have all the same problems as
global state.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

###To recap, we just covered:

- Names Are Important
- The Principle of Least Surprise
- Make interfaces impossible to use incorrectly
- Avoid Aliasing

What is the common through-line in all of those?

Your code must be easy to reason about to be usable.
<!-- .element: class="fragment" data-fragment-index="1" -->

These are not actually separate topics, but different aspects of the same
principle.
<!-- .element: class="fragment" data-fragment-index="2" -->

====================

# Part 3.5
## Usability (Specifically Composability)

----

        </script>
      </section>
    </div>
  </div>

  <script src="presentation/lib/js/head.min.js"></script>
  <script src="presentation/js/reveal.min.js"></script>
  <script>
    Reveal.initialize({
        slideNumber: true,

        dependencies: [
            { src: 'presentation/lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'presentation/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'presentation/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'presentation/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'presentation/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
            { src: 'presentation/plugin/math/math.js', async: true },
            { src: 'presentation/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
    });
  </script>
</body>

</html>

